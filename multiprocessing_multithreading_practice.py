# IMPORTS
import multiprocessing
import threading
import random
import string


class CreateThreads(threading.Thread):
    def __init__(self, shared_queue, GIL_lock):
        '''
            :param shared_queue: shared_queue which contain all string and this queue is shared by every processes
            :param GIL_lock:  Global Interpreter Lock (used to prevent dead locks)
        '''
        threading.Thread.__init__(self)
        self.shared_queue = shared_queue
        self.GIL_lock = GIL_lock
        self._stop_event = threading.Event()

    def run(self):
        '''
            run method will run when thread start running
        '''
        # target function of the thread class
        try:
            while True:
                self.GIL_lock.acquire()
                if self.shared_queue.empty():  # check if queue is not empty
                    self.GIL_lock.release()
                    self.stop()
                    break

                q_string = self.shared_queue.get()
                self.GIL_lock.release()

                self.GIL_lock.acquire()
                print("Thread id : {} and string is : {}".format(threading.current_thread().name, q_string))
                self.GIL_lock.release()
        except Exception as e:
            print(e)

    def stop(self):
        '''
            This method is used to stop the thread
        '''
        self.GIL_lock.acquire()
        print("Thread id : {} Exit! ".format(threading.current_thread().name))
        self.GIL_lock.release()
        self._stop_event.set()


# ============================= #
#       Required Functions
# ============================= #

def create_string(number, size=4):
    '''
        :param number: string number
        :param size: size of string
        :return: rand_str:  rand_str is a string which is generated by this function
    '''
    rand_str = ''.join(random.choices(string.ascii_uppercase + string.digits, k=size))
    rand_str += " : string number : {}".format(number)
    return rand_str


def create_threads(number_of_threads, shared_queue, GIL_lock):
    '''
        :param number_of_threads: Number of threads this process will make
        :param shared_queue: shared_queue which contain all string and this queue is shared by every processes
        :param GIL_lock: Global Interpreter Lock (used to prevent dead locks)
        :return:
    '''
    threads = []
    for _ in range(number_of_threads):  # each Process creates 10 number of  Threads
        thread = CreateThreads(shared_queue, GIL_lock)
        threads.append(thread)
        thread.start()

    for thread in threads:  # All threads will be join here after completing there tasks
        thread.join()


# ============================= #
#       main Function
# ============================= #
if __name__ == "__main__":
    processes = []
    GIL_lock = multiprocessing.Lock()
    shared_queue = multiprocessing.Queue()  # Shared memory queue for all processes queue
    [shared_queue.put(create_string(i, 4)) for i in range(100)]  # populate queue

    for _ in range(4):  # Creating 4 process
        p = multiprocessing.Process(target=create_threads, args=(10, shared_queue, GIL_lock))  # create a new Process
        p.start()
        processes.append(p)

    for process in processes:  # All processes will be join here
        process.join()

    for process in processes:  # All created processes will terminate
        process.terminate()